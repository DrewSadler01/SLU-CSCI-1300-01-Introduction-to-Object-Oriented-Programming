# -*- coding: utf-8 -*-
"""Copy of Final Exam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18S8TW9Nk7jB7AielLPEQ-b5sr_klXgAA

# Exam Instructions


1.   Read these instructions carefully
2.   Make a copy of this document:

     `File->Save a copy in Drive...`
3.   Complete the exam by placing your answers in the space provided. ONLY use the space provided. 
4.   Download your solution as a Python file:

    `Download .py`
5.   Submit the downloaded file to your git repository under `exam03` directory.

Please note that for questions that involve executable code, you may run your code directly on this site by clicking the "play" button in the top left corner of the code. You are allowed to test using Python on your own computer, but please make sure that your answers are properly transcribed to this exam.

# Academic Integrity

While you are free to reference the book, notes from this class, or general Python references, you may not seek any direct or indirect help to answer the specific exam questions, nor are you to communicate with anyone else regarding the exam.  All answers most be entirely your own work.

Any violation of the Academic Integrity policy will result in the grade of zero for this exam. Additionally, anyone caught violating the Academic Integrity policy will be prohibited from taking the final exam in this course.

Please sign your name in the box below to confirm that all answers are your own.
"""

# I have abided by the policy on Academic Integrity
# and all answers given below are my own.
#
# [Drew Sadler]

"""# Exam Time

This exam is designed to be completed in the typical two-hour window, and we are okay if you choose to take a third hour given the unusual circumstances. In the space below, please report your personal start time and end time for completing this exam.
"""

# Start time: 2:43pm
# End time: 8:17pm

"""# Question 1 (10 points)

Give Python code that expresses the following flow of control, presuming the use of A, B, C, D as boolean expressions and V, W, X, Y, Z as executable statements.
**Your code should express this logic using each of the above characters once and only once.**

![flow.png](data:image/png;base64,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)

We will get you started. Please complete the code below.
"""

# Your answer here
if A:
  if C:
    W
  Y
else:
  if B:
    V
  else:
    if D:
      X
  Z

"""# Question 2 (10 points)

Python's `list` class supports a method with signature `pop(k)` that removes and returns the element at index `k` of the list.

Strings in Python are not mutable so they do not provide such a way to remove the character at a given index.  Implement a function with signature `strpop(s,k)` that returns a new string that is modeled from original string `s` but with the character at index `k` no longer there.  For example, the call `strpop('tired',2)` should return `tied`. For the sake of this problem, you may assume that `s` is a nonempty string and that `k` is a valid index for that string.

**To receive full credit, your solution must take advantage of string slicing to compose the desired result. You should not need a loop.**
"""

# Your answer here

def strpop(s,k):
  temp=[]
  word=""
  for a in (s):
    temp.append(a)
  temp.pop(k)
  for b in range(len(temp)):
    word+=temp[b]
  return(word)


#####################################
# testing
#####################################
print(strpop('tired',2))

"""# Question 3 (10 points)

Implement a function `findRecentRepeat(n,k)` that performs the following probabilistic experiment.  It should repeatedly sample with the `randrange(n)` function from the `random` module (which returns an integer uniformly distributed from 0..n-1).  This process should continue until the first time that a selection is equal to one of the `k` most recent samples, and the function must return the total number of samples that were drawn. **You may assume that `n` and `k` are both positive integers.**

Some examples of possible experiments are as follows:

* `findRecentRepeat(4,2)` would return `5` if faced with the following random samples: `0,3,1,0,1,...`.   Notice that the final selection was equal to the sample that was two earlier.
* `findRecentRepeat(8,3)` would return `4` if faced with the following random samples: `7,2,6,6,...`. Notice that the final selection was equal to one that was among the previous three.
* `findRecentRepeat(6,4)` would return `2` if faced with the following random samples: `3,3,...`.  Notce that the final selection was among the previous four samples (and it wasn't necessary to have four previous samples to detect such a repeat).
"""

# Your answer here
from random import randrange

def findRecentRepeat(n, k):
  Check=False
  temp=[]
  count=0
  while Check==False:
    temp.append(randrange(n))
    count=count+1
    if count>=k:
      if len(temp)==2:
        if temp[0]==temp[1]:
          check=True
          return count
      else:    
        for a in range(len(temp)-k-1,len(temp)-1): 
          if temp[-1]==temp[a]:
            Check=True
            return count

"""# Question 4 (10 points)

We are interested in analyzing weather forecasts. In particular, we assume we represent a series of daily forecast as a *nonempty tuple of tuples* with each inner tuple being a pair of integers (*low*, *high*) with *low* $\leq$ *high*; each such pair represents the low and high temperature forecasted for a day in the series. For example we might have the following:
```
example = ( (44,57), (44,62), (49,57), (37,59), (45,61) )
```

Your task is to implement a function `biggestDifference(forecast)` that returns an integer equal to the largest observed difference between a day's high and low temperatures.  For example, for the forecast given above, `biggestDifference` should return `22`, as achieved for the day with low=37 and high=59.

**For the sake of this question, you may assume the parameter meets the expectations defined above.** (We revisit validation of those expectations in a later question.)
"""

# Your answer here

def biggestDifference(forecast):
  weather=[]
  for minTemp,maxTemp in example:
    if minTemp<=maxTemp:
      tempDiff=(maxTemp-minTemp)
    else:
      tempDiff=(minTemp-maxTemp)
    weather.append(tempDiff)
  return(max(weather))

#####################################
# testing
#####################################
example = ((44,57), (44,62), (49,57), (37,59), (45,61))
print(biggestDifference(example))

"""# Question 5 (10 points)
The previous question involved a function `biggestDifference(forecast)` that made the assumption that the parameter is a **nonempty tuple of tuples**, with each inner tuple being a pair of integers (*low*, *high*) with *low* $\leq$ *high*.

In the previous question you were allowed to assume the parameter met such expectations.  For this problem, you are to provide an implementation that explicitly checks all such conditions, raising appropriate Error types when a problem is detected.

**Do not reimplement the logic from your previous solution. Your new implementation is only responsible for validating the expectations for the parameter.**
"""

# Your answer here

def biggestDifference(forecast):
  for a in range(len(forecast)):
    if(type(a)!=tuple):
      raise TypeError("a must be a tuple as a whole")
    if(a[1]<a[0]):
      raise ValueError("High cannot be lower than Low")
    if(type(a[1])!=int):
      raise TypeError("High must be a int value")
    if(len(a)==0):
      raise ValueError("a must have values inside it")
    if(type(a[0])!=int):
      raise TypeError("Low must be a int value")
    if(a[0]>a[1]):
      raise ValueError("Low cannot be greater than the High value")
  if(type(forecast)!=tuple):
    raise TypeError("forecast has to be a tuple itself")
  if(len(forecast)==0):
    raise ValueError("forecast has to contain some values")

"""# Question 6 (10 points)

Continuing with our theme of weather forecasting, we have decided that we wish to have a custom class to represent a daily forecast.  You are responsible for implementing a `DailyForecast` class that meets the following specifications. (**For the sake of this question, you may simply assume that all parameters are valid.**)

* The **constructor** accepts two parameters *low* and *high* that are integers such that *low* $\leq$ *high*.
* A method with calling syntax **`getLow()`** returns the low temperature for the day
* A method with calling syntax **`getHigh()`** returns the high temperature for the day
* A method with calling syntax **`getDifference()`** returns the difference between the high and low temperatures. Thus `DailyForecast(50,72).getDifference()` should return `22`
"""

# Your answer here

class DailyForecast:
  def __init__(self,low,high):
    self._low=low
    self._high=high
  def getLow(self):
    return self._low
  def getHigh(self):
    return self._high
  def getDifference(self):
    difference=((self._high)-(self._low))
    return difference

#####################################
# testing
#####################################
print(DailyForecast(50,72).getDifference())

"""# Question 7 (10 points)
Next, we wish to have a class to maintain a longterm forecast, which is itself a collection of daily forecasts.  For this question, you are to assume the existence of a `DailyForecast` class as defined in the previous question (i.e., you do **not** need to reimplement that here).

You are responsible for defining a new `LongtermForecast` class with the following functionality. (**For the sake of this question, you may simply assume that all parameters are valid.**)
* The **constructor** takes no parameters and creates a longterm forecast that does not have any days.
* The **`append(day)`** method accepts a `DailyForecast` instance and adds it to the *end* of the longterm forecast. 
* The **`flush(k)`** method removes the *earliest* `k` days from the forecast, where `k` is assumed to be a nonnegative integer that is no greater than the current number of forecasted days.
* The **`__len__`** method returns the current number of forecasted days.
* The **`maxTemp(k)`** method reports the hotest temperature that is forecasted within the next `k` days for a given `k` that is a nonnegative integer no greater than the current number of forecasted days.

A sample usage of this class might appear as follows:
```
upcoming = LongtermForecast()
upcoming.append(DailyForecast(50,73))
upcoming.append(DailyForecast(48,68))
upcoming.append(DailyForecast(55,80))
upcoming.append(DailyForecast(56,76))
upcoming.append(DailyForecast(52,77))
m = len(upcoming)                      # should be 5
hot = upcoming.maxTemp(2)              # should be 73
hotter = upcoming.maxTemp(4)           # should be 80
upcoming.flush(3)
n = len(upcoming)                      # should be 2
mild = upcoming.maxTemp(1)             # should be 76
```
"""

# Your answer here

class LongtermForecast:
  def __init__(self):
    self._WeatherWeek=[]
  def append(self,day):
    self._WeatherWeek.append(day)
  def flush(self,k):
    for a in range(k):
      self._WeatherWeek.pop(0)
    return self._WeatherWeek
  def __len__(self):
    return(len(self._WeatherWeek))
  def maxTemp(self,k):
    temp=0
    for b in range(k):
      self._WeatherWeek[b].getHigh()
      if (self._WeatherWeek[b].getHigh())>temp:
        temp=(self._WeatherWeek[b].getHigh())
      else:
        pass
    return temp


#####################################
# testing
#####################################
upcoming = LongtermForecast()
upcoming.append(DailyForecast(50,73))
upcoming.append(DailyForecast(48,68))
upcoming.append(DailyForecast(55,80))
upcoming.append(DailyForecast(56,76))
upcoming.append(DailyForecast(52,77))
m = len(upcoming)                      # should be 5
hot = upcoming.maxTemp(2)              # should be 73
hotter = upcoming.maxTemp(4)           # should be 80
upcoming.flush(3)
n = len(upcoming)                      # should be 2
mild = upcoming.maxTemp(1)             # should be 76

print(m,hot,hotter,n,mild)

"""# Question 8 (10 points)
Recall the `Account` and `ChargeCard` classes from earlier in the semester (code given below). The `Account` class models a bank account while the `ChargeCard` class models a credit card.

In our implementation of the `ChargeCard`, you are not allowed to make purchases that exceed a card's limit. Use inheritance to implement a `SecureChargeCard` class, as a sub-class (child class) of `ChargeCard`. The `SecureChargeCard` will have a secondary `Account` associated with it (passed in the constructor of `SecureChargeCard`). The `SecureChargeCard` must override the `charge` method of its parent class, such that if the amount being charged exceeds the card's limit, the excess amount required will be withdrawn from the secondary account (if funds are available).

The code below shows the details of `Account` and `ChargeCard` classes as well as an example usage of the `SecureChargeCard` class.

Your `SecureChargeCard` must have:


*   a constructor with two required parameters: card limit and secondary Account object.  (The initial balance for a `SecureChargeCard` should always be zero.)
*   `charge(amount)` method, which returns `True` if the charge is successful as defined above. Note that as much of the charge as possible should be placed on the credit card; the secondary account should only be used for any excess amount. The method returns `False` if there there are not sufficient funds available even when considering the secondary account. In this case, no balances should be affected.

**For the sake of this question, you may assume all parameter meet expectaitons.**


Write your implementation of `SecureChargeCard` in the space provided. Do NOT alter the implementation of `Account` or `ChargeCard` classes.
"""

class Account:

    def __init__(self, balance=0.0):
        self._balance = balance
  
    def __eq__(self, other):
        return self._balance == other._balance
  
    def __str__(self):
        return 'current balance is ' + str(self._balance)
  
    def getBalance(self):
        return self._balance
  
    def deposit(self, amount):
        self._balance += amount
  
    def withdraw(self, request):
        if request > self._balance:
            raise ValueError('Insufficient Funds')
        self._balance -= request
        return request

class ChargeCard:
    def __init__(self, limit, balance=0):
        if not isinstance(balance, (int, float)):
            raise TypeError
        if limit <= 0:
            raise ValueError
        self._balance=balance
        self._limit=limit
        
    def getBalance(self):
        return self._balance
    
    def getLimit(self):
        return self._limit
    
    def charge(self, amount):
        if not isinstance(amount, (int, float)):
            raise TypeError
        if amount <= 0:
            raise ValueError
        retValue = False
        if self._balance+amount <= self._limit:
            self._balance+=amount
            retValue = True
        return retValue
    
    def deposit(self, amount):
        if not isinstance(amount, (int, float)):
            raise TypeError
        if amount <= 0:
            raise ValueError
        self._balance-=amount


    def __str__(self):
        return f'limit: {self._limit}, Balance: {self._balance}'


##################################################################
# Write your implementation of SecureChargeCard below this comment
##################################################################
class SecureChargeCard(ChargeCard):
  def __init__(self,limit,Account):
    super().__init__(limit)
    self._Account=Account
  def charge(self,amount):
    if not isinstance(amount, (int, float)):
      raise TypeError
    if amount <= 0:
      raise ValueError
    retValue = False
    if self._balance+amount <= self._limit:
      self._balance+=amount
      retValue = True
    else:
      if (self._balance+amount)<=(self._limit+self._Account.getBalance()):
        credit=(self._balance+amount-self._limit)
        self._Account.withdraw(credit)
        self._balance=(self._balance+amount-credit)
        retValue = True
    return retValue


##################################################################
# Example usage of SecureChargeCard class
##################################################################
if __name__ == '__main__':
    bankAccount = Account()
    bankAccount.deposit(100)
    chargeCardLimit = 1000
    secureCard = SecureChargeCard(chargeCardLimit, bankAccount)

    # 500 dollars get charged to secureCard
    # result should be True
    result = secureCard.charge(500)
    print(result)

    # Charge $600 to secureCard
    # This charge will be allowed: 
    # - $500 will be charged to secureCard
    # - $100 will get taken from bankAccount (because bankAccount is the secondary account)
    # result should be True
    result = secureCard.charge(600)
    print(result)

    # deposit money to the bank account
    result = bankAccount.deposit(50)

    # attempt a $100 charge to secureCard, this charge should get rejected 
    # (the card is at the limit and there are not enough funds in the bank account)
    # result should be False
    result = secureCard.charge(100)
    print(result)

"""# Question 9 (10 points)
Given a dictionary, `inner`, and another dictionary, `outer`, we define the *composition* of the two dictionaries to be a dictionary such that `composition[k] = outer[inner[k]]` for all `k` for which `outer[inner[k]]` is well-defined.

You are to write a function with calling signature **`compose(inner, outer)`** that returns a new dictionary representing such a composition.  As an example, given the following definitions


```
mascot = {'SLU' : 'Billikens', 'Missouri':'Tigers',
          'Louisville':'Cardinals', 'Clemson' : 'Tigers'}

color = {'Tigers':'Yellow', 'Cardinals' :'Red',
        'Spiders' : 'Black'}
```


`compose(mascot,color)` should return


```
{'Missouri':'Yellow', 'Louisville':'Red', 'Clemson':'Yellow'}
```
"""

# Your solution here

def compose(inner, outer):
  complete={}
  for a in (inner):
    for b in (outer):
      if(inner[a]==b):
        complete[a]=[outer[b]]
  return(complete)

#####################################
# testing
#####################################
mascot = {'SLU' : 'Billikens', 'Missouri':'Tigers',
          'Louisville':'Cardinals', 'Clemson' : 'Tigers'}
 
color = {'Tigers':'Yellow', 'Cardinals' :'Red',
        'Spiders' : 'Black'}

result = compose(mascot,color)
print(result)

"""# Question 10 (10 points)

The textbook defines the OurList class as a recursive implementation of a list. We provide a minimal working example of that implementation below as your starting point.

The `__eq__` method of a class is used to define the semantics of equivalency, in that expression `a == b` is evaluated as `a.__eq__(b)`.  Recall that two lists are considered to be equivalent when the have equivalent contents on an element-by-element basis.

Give a (recursive) implementation of an `__eq__` method for the `OurList` class that properly captures the notion of two lists being equivalent to each other. Be careful to consider all possible base cases!

**Your implementation may use the `_isEmpty` utility method, but we have intentionally removed most other methods of our class. You should be able to implement `__eq__` based only on this implementation.**
"""

##########################################
#
##########################################
class OurList:

    def __init__(self):
        self._head = None
        self._rest = None

    def _isEmpty(self):
        return self._rest is None

    def append(self, value):
        if self._isEmpty():
            self._head = value        # now we have one element
            self._rest = OurList()    # followed by new empty list
        else:
            self._rest.append(value)  # pass it on


##########################################
# Place your answer here (indented as given so it remains part of the above class)
##########################################
    def __eq__(self, other):
      return self._rest==other




##########################################
# Some testing...(you should do more)
##########################################       
first = OurList()
first.append('A')
first.append('B')
first.append('C')

second = OurList()
second.append('A')
second.append('B')
second.append('C')

print(first == second)     # should be True
first.append('D')
print(first == second)     # should be False